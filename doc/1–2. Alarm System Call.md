## 1â€“2. Alarm System Call â°

### ê³¼ì œ ëª©í‘œğŸ¯

ê¸°ìƒì„ ìœ„í•´ ì •í•´ì§„ ì‹œê°„ì´ ë˜ë©´(ë˜ëŠ” ì§€ë‚˜ë©´) ìš¸ë¦¬ëŠ” ì•ŒëŒì²˜ëŸ¼ ì´ë²ˆ ê³¼ì œì—ì„œì˜ **Alarm(ì•ŒëŒ)**ì€ í˜¸ì¶œí•œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì •í•´ì§„ ì‹œê°„ í›„ì— ë‹¤ì‹œ ì‹œì‘í•˜ëŠ” ì»¤ë„ì˜ ë‚´ë¶€ í•¨ìˆ˜ì´ë‹¤.

ê¸°ë³¸ì ìœ¼ë¡œ Pintosì—ì„œ ì œê³µí•˜ëŠ” ì•ŒëŒ ê¸°ëŠ¥ì€ **Busy waiting**ì„ ì´ìš©í•˜ì—¬ êµ¬í˜„ë˜ì–´ ìˆëŠ”ë°, ì´ë²ˆ ê³¼ì œì—ì„œëŠ” **Sleep/Wake up**ì„ ì´ìš©í•˜ì—¬ ì¬êµ¬í˜„ í•˜ëŠ” ê²ƒì´ ëª©í‘œì´ë‹¤.

#### Busy waiting

busy-looping ë˜ëŠ” spinningì´ë¼ê³ ë„ ë¶ˆë¦¬ëŠ” ì´ ê¸°ë²•ì€ í”„ë¡œì„¸ìŠ¤ê°€ **ë°˜ë³µì ìœ¼ë¡œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ ì²´í¬**í•œë‹¤. ê³„ì†í•´ì„œ ì¡°ê±´ ë§Œì¡± ì—¬ë¶€ë¥¼ ì²´í¬í•˜ê¸° ë•Œë¬¸ì— ì¶©ë¶„í•œ ìˆ™ë©´ì„ ì·¨í•˜ê¸° ì–´ë ¤ìš´ ë°©ì‹ì´ë‹¤.ğŸ¥±

![img](https://cdn-images-1.medium.com/max/1000/0*8IYftOBz7HbP9MFo.jpg)

> [rinzzzz, Process Synchronization with Busy waiting](https://dev.to/rinsama77/process-synchronization-with-busy-waiting-4gho)

#### Sleep/Wake up

Busy waitingê³¼ëŠ” ë‹¬ë¦¬ **í”„ë¡œì„¸ìŠ¤ë¥¼ sleep ì‹œí‚¤ê³  ì •í•´ì§„ ì‹œê°„ í›„ì— ì•ŒëŒì„ í†µí•´ ê¹¨ìš°ëŠ” ë°©ì‹**ìœ¼ë¡œ ì•ŒëŒì´ ìš¸ë¦¬ê¸° ì „ê¹Œì§€ëŠ” ì¡°ê±´ ë§Œì¡± ì—¬ë¶€ë¥¼ ì²´í¬í•˜ì§€ ì•Šê³  í‘¹ ì˜ ìˆ˜ ìˆë‹¤.ğŸ˜´

<hr/>

### êµ¬í˜„ğŸ‘©ğŸ»â€ğŸ’»

Sleep/Wake up ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„œëŠ” `timer_sleep()`ì„ í˜¸ì¶œí•˜ì—¬ sleep ìƒíƒœê°€ ëœ ìŠ¤ë ˆë“œë¥¼ ì‚½ì…í•  **Sleep queue**ë¥¼ ë§Œë“¤ì–´ë³´ì.

1. ìŠ¤ë ˆë“œê°€ ê¹¨ì–´ë‚˜ì•¼ í•  ì‹œê°„ì— ëŒ€í•œ ì •ë³´ë¥¼ ìŠ¤ë ˆë“œë³„ë¡œ ê°€ì§€ê³  ìˆì–´ì•¼ í•˜ë¯€ë¡œ `thread` êµ¬ì¡°ì²´ì— ê´€ë ¨ ì •ë³´ë¥¼ ë‹´ì€ ë³€ìˆ˜ë¥¼ ì¶”ê°€í•œë‹¤.

   ````c
   /* pintos/src/thread/thread.h */
   
   struct thread
   {
     ...
     /* ê¹¨ì–´ë‚˜ì•¼ í•  tickì„ ì €ì¥í•  ë³€ìˆ˜ ì¶”ê°€ */
     int64_t wakeup_tick;
     ...
   }
   ````

   

2. sleep ìƒíƒœì˜ ìŠ¤ë ˆë“œë¥¼ ì €ì¥í•˜ì—¬ ê´€ë¦¬í•  ìë£Œêµ¬ì¡°ì¸ `sleep_list` ì™€ ê°€ì¥ ë¨¼ì € ê¹¨ì›Œì•¼ í•  ìŠ¤ë ˆë“œê°€ ì¼ì–´ë‚  ì‹œê°, ì¦‰ `sleep_list` ì—ì„œ ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œë“¤ì˜ `wakeup_tick` ê°’ ì¤‘ ìµœì†Ÿê°’ì„ ì €ì¥í•  `next_tick_to_awake`ë¥¼ ì „ì—­ ë³€ìˆ˜ë¡œ ì„ ì–¸í•œë‹¤. `sleep_list`ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ ì´ˆê¸°í™” ì‘ì—…ë„ í•œë‹¤.

   ```c
   /* pintos/src/thread/thread.c */
   
   static struct list sleep_list;
   static int64_t next_tick_to_awake;
   
   void
   thread_init (void)
   {
     ...
     list_init (&sleep_list);    /* sleep_listë¥¼ ì´ˆê¸°í™” */
     ...
   }
   ```

   

3. ì´ì œ ìŠ¤ë ˆë“œë¥¼ ì¬ìš°ê¸° ìœ„í•œ ì¤€ë¹„ ì‘ì—…ì„ í•´ë³´ì. ìê¸° ì „ì— ê¹¨ì–´ë‚  ì‹œê°„ì— ëŒ€í•œ ì •ë³´ë¥¼ ë¨¼ì € ê´€ë¦¬í•´ ì£¼ì–´ì•¼ í•˜ë¯€ë¡œ, `next_tick_to_awake` ê°€ ê¹¨ì›Œì•¼ í•  ìŠ¤ë ˆë“œ ì¤‘ ê°€ì¥ ì‘ì€ tick ê°’ì„ ê°€ì§€ë„ë¡ ì—…ë°ì´íŠ¸í•˜ëŠ” `update_next_tick_to_awake()`ì™€ ê·¸ ê°’ì„ ë°˜í™˜í•˜ëŠ” `get_next_tick_to_awake()`ë¥¼ êµ¬í˜„í•œë‹¤.

   ```c
   /* pintos/src/thread/thread.c */
   
   void
   update_next_tick_to_awake (int64_t ticks)
   {
     next_tick_to_awake = (ticks < next_tick_to_awake) ? ticks : next_tick_to_awake;
   }
   
   int64_t
   get_next_tick_to_awake (void)
   {
     return next_tick_to_awake;
   }
   ```



4. `timer_sleep()`ì—ì„œ `thread_sleep()` ì„ í˜¸ì¶œí•¨ìœ¼ë¡œì¨ ìŠ¤ë ˆë“œë¥¼ ì¬ì›Œ `sleep_list`ì— ë„£ëŠ”ë‹¤. ì´ë•Œ ì¤‘ê°„ì— ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ë©´ ì˜ˆê¸°ì¹˜ ëª»í•œ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì‚¬ì „ì— í˜„ì¬ ìŠ¤ë ˆë“œê°€ ë…ì ì ìœ¼ë¡œ ì‹¤í–‰ë  ìˆ˜ ìˆë„ë¡ `intr_disable()` ì‹œí‚¤ê³  ëª¨ë“  ì‘ì—…ì„ ìˆ˜í–‰í•˜ê³  ë‚˜ì„œ ë§ˆì§€ë§‰ì— `intr_set_level()`ë¡œ ê¸°ì¡´ì˜ ì¸í„°ëŸ½íŠ¸ ë ˆë²¨ë¡œ ë³µêµ¬í•˜ê³  ì¸í„°ëŸ½íŠ¸ë¥¼ í—ˆìš©í•œë‹¤.

   ```c
   /* pintos/src/threads/thread.c */
   
   void
   thread_sleep (int64_t ticks)
   {
     /* ì´ì „ ì¸í„°ëŸ½íŠ¸ ë ˆë²¨ì„ ì €ì¥ í›„ ì¸í„°ëŸ½íŠ¸ ë°©ì§€ */
     enum intr_level old_level = intr_disable ();  
     struct thread *cur = thread_current ();
     
     /* í˜„ì¬ ìŠ¤ë ˆë“œëŠ” idle ìŠ¤ë ˆë“œê°€ ì•„ë‹ˆì–´ì•¼ í•¨ â†’ idleì´ë©´ í”„ë¡œê·¸ë¨ ì¤‘ë‹¨ */
     ASSERT(cur != idle_thread);                   
     cur->wakeup_tick = ticks;
     
     list_push_back(&sleep_list, &cur->elem);
       
     /* ê¹¨ì–´ë‚˜ì•¼ í•  tickì„ update */
     update_next_tick_to_awake(ticks);
       
     /* í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ blocked statusë¡œ ë§Œë“¤ê³  ìŠ¤ì¼€ì¤„ë§ */
     thread_block ();
       
     /* ì¸í„°ëŸ½íŠ¸ ë ˆë²¨ì„ ë³µêµ¬í•˜ê³  ì¸í„°ëŸ½íŠ¸ í—ˆìš© */
     intr_set_level(old_level);                    
   }
   ```

   > *ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰í•  ì¤€ë¹„ê°€ ë˜ì§€ ì•Šì€ ê²½ìš° CPUì—ì„œ ì‹¤í–‰ë˜ëŠ” íŠ¹ìˆ˜ ìŠ¤ë ˆë“œì¸ **idle threadëŠ” í•­ìƒ ready listì— ìŠ¤ë ˆë“œê°€ ì¡´ì¬í•˜ë„ë¡ í•¨ìœ¼ë¡œì¨ CPUê°€ êº¼ì§€ì§€ ì•Šë„ë¡ í•œë‹¤.** ì‹¤í–‰í•  ìŠ¤ë ˆë“œê°€ ì—†ì–´ CPUë¥¼ ê»ë‹¤ê°€ í•„ìš”í•  ë•Œ í‚¤ëŠ” ê²ƒë³´ë‹¤ëŠ” ë¬´ì˜ë¯¸í•œ ì¼ì´ë¼ë„ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ ë¹„ìš©ì´ ì ê²Œ ë“¤ê¸° ë•Œë¬¸ì´ë‹¤.*

   

5. ì´ì œ ì ì ˆí•œ ì‹œê°„ì´ ì§€ë‚˜ë©´ ìŠ¤ë ˆë“œë¥¼ ê¹¨ì›Œì•¼ í•œë‹¤. `sleep_list`ë¥¼ ìˆœíšŒí•˜ë©° í˜„ì¬ tickì´ ê¹¨ì›Œì•¼ í•  tickë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤ë©´ ìŠ¤ë ˆë“œë¥¼ ê¹¨ì›Œ `sleep_list`ì—ì„œ ì œê±°í•˜ê³  unblock ì‹œí‚¤ê³ , í¬ë‹¤ë©´ `update_next_tick_to_awake()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ìµœì†Œ tick ê°’ì„ ê°€ì§€ë„ë¡ `thread_awake()`ë¥¼ êµ¬í˜„í•œë‹¤.

   ```c
   /* pintos/src/thread/thread.c */
   
   void
   thread_awake (int64_t ticks)
   {
     next_tick_to_awake = INT64_MAX;
     struct list_elem *e = list_begin(&sleep_list);
     
     while(e != list_end(&sleep_list))
     {
       struct thread *t = list_entry(e, struct thread, elem);
       if (ticks >= t->wakeup_tick)
       {
         e = list_remove(&t->elem);
         thread_unblock(t);
       }
       else
       {
         e = list_next(e);
         update_next_tick_to_awake(t->wakeup_tick);
       }
     }
   }
   ```

   

6. ì´ë ‡ê²Œ ì´ë²ˆ ê³¼ì œì—ì„œ í•„ìš”í•œ thread.cì—ì„œ êµ¬í˜„í•´ì•¼ í•  ê²ƒë“¤ì„ ì™„ì„±í–ˆë‹¤ë©´ thread.hì— í•¨ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.

   ```c
   /* pintos/src/thread/thread.h */
   
   void thread_sleep (int64_t ticks);
   void thread_awake (int64_t ticks);
   
   void update_next_tick_to_awake (int64_t ticks);
   int64_t get_next_tick_to_awake (void);
   ```

   

7. timer.cë¡œ ë„˜ì–´ì™€ì„œ ê¸°ì¡´ì— êµ¬í˜„ë˜ì–´ ìˆë˜ `timer_sleep()`ì„ ì‚´í´ë³´ì.

   ìœ„ ì½”ë“œëŠ” while loopë¥¼ ëŒë©´ì„œ ì§€ì†ì ìœ¼ë¡œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ ì²´í¬í•˜ëŠ” Busy waiting ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ë˜ì–´ ìˆë‹¤. ë”°ë¼ì„œ ê¸°ì¡´ì˜ Busy waitingì„ ìœ ë°œí•˜ëŠ” ì½”ë“œë¥¼ ì‚­ì œí•˜ê³  ìƒˆë¡œ êµ¬í˜„í•œ ìŠ¤ë ˆë“œë¥¼ sleep queueì— ì‚½ì…í•˜ëŠ” `thread_sleep() `í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë„ë¡ ìˆ˜ì •í•œë‹¤.

   ```c
   /* pintos/src/devices/timer.c */
   
   void
   timer_sleep (int64_t ticks)
   {
     int64_t start = timer_ticks ();
     ASSERT (intr_get_level () == INTR_ON);
     
     while (timer_elapsed (start) < ticks)    /* busy waiting ìœ ë°œ */
     {
       thread_yield ();
     }
   }
   ```

   

8. ë§ˆì§€ë§‰ìœ¼ë¡œ ë§¤ tickë§ˆë‹¤ `sleep_list`ì—ì„œ ê¹¨ì–´ë‚  `thread` ê°€ ìˆëŠ”ì§€ í™•ì¸í•´ì„œ ìˆë‹¤ë©´ `thread_awake()`ë¥¼ í˜¸ì¶œí•˜ë„ë¡ `timer_interrupt()`ë¥¼ ìˆ˜ì •í•œë‹¤.

   ```c
   /* pintos/src/devices/timer.c */
   
   void
   timer_sleep (int64_t ticks)
   {
     int64_t start = timer_ticks ();
     ASSERT (intr_get_level () == INTR_ON);
         
     thread_sleep (start + ticks);
   }
   ```



<hr/>

### ê²°ê³¼ğŸ˜´ğŸ˜„

```shell
/* pintos/src/threads */

sudo make
pintos -- -q run alarm multiple
```

ìœ„ ëª…ë ¹ì–´ë¥¼ í†µí•´ ë‹¤ìŒê³¼ ê°™ì€ ê²°ê³¼ë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆìœ¼ë©° ì´ëŠ” ê¸°ì¡´ì˜ Busy waiting ë°©ì‹ê³¼ëŠ” **idle tick**ì—ì„œ ì°¨ì´ë¥¼ ë³´ì¸ë‹¤. â°

- Sleep/Wake up ë°©ì‹

  ![img](https://cdn-images-1.medium.com/max/1000/1*-PLKSJQQ_JYCEI11w70pJQ.png)

- Busy waiting ë°©ì‹

  ![img](https://cdn-images-1.medium.com/max/1000/1*awR0gycLkWGMGhsd4i3ARg.png)

ì´ë ‡ê²Œ ì°¨ì´ê°€ ë°œìƒí•˜ëŠ” ì´ìœ ëŠ” ê¸°ì¡´ì˜ **Busy waiting** ë°©ì‹ì—ì„œëŠ” **sleep ìƒíƒœì—ì„œë„ ìŠ¤ë ˆë“œê°€ CPUë¥¼ ì ìœ **í•˜ê³  ìˆì–´ idle tickì´ 0ì´ì—ˆì§€ë§Œ, **Sleep/Wake up** ë°©ì‹ì—ì„œëŠ” **CPUê°€ idle ìŠ¤ë ˆë“œë¥¼ ì ìœ **í•˜ê²Œ ë˜ì–´ ê·¸ íšŸìˆ˜ë§Œí¼ idle tickì´ ì¦ê°€í•œ ê²ƒì´ë‹¤. ê²°ê³¼ì ìœ¼ë¡œ ìŠ¤ë ˆë“œê°€ sleep ìƒíƒœì— ìˆì„ ë•Œ ìì›ì˜ ë‚­ë¹„ë¥¼ ì¤„ì—¬ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤.ğŸ‘