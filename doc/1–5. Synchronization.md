## 1–5. Synchronization

이번 포스팅에서는 **동기화(Synchronization)**에 대해서 알아보도록 하자.

![img](https://cdn-images-1.medium.com/max/1000/0*I_iKMeYKLszw-68_.jpg)

> [race condition](https://dev.to/rinsama77/process-synchronization-with-busy-waiting-4gho)

다수의 작업을 동시에 실행시키는 멀티태스킹의 등장으로 병렬적으로 일을 처리함에 따라 응용프로그램의 실행 시간, 사용자에 대한 응답시간을 단축할 수 있게 되었다. 그러나 다수의 작업들이 공유 데이터에 동시에 접근하게 될 시에는 데이터가 훼손되는 문제가 발생할 수 있다. 즉, 여러 스레드가 공유 변수에 접근하려고 **경쟁(race)** 하는 상황에서 적절한 처리가 되지 않는다면 아래와 같이 의도치 않은, 잘못된 데이터가 저장될 가능성이 존재한다.🙄

![img](https://cdn-images-1.medium.com/max/1000/0*5gmJ3Ui_XicshRTA.png)race 

> [condition example](http://opensourceforgeeks.blogspot.com/2014/01/race-condition-synchronization-atomic.html)

이러한 문제를 해결하기 위한 방법인 **동기화**는 한 스레드가 공유 데이터에 대해 독점적으로 접근하도록 함으로써 다수의 스레드가 충돌 없이 공유 데이터에 접근하여 공유 데이터의 훼손을 방지한다.

### 상호배제(Mutual Exclusion)

**상호배제**는 임계 구역에 먼저 진입한 스레드가 독점적으로 해당 구역의 실행을 끝낼 때까지 다른 스레드가 진입하지 못하도록 관리하여 공유 데이터의 훼손을 방지하는 알고리즘이다.

![img](https://cdn-images-1.medium.com/max/1000/0*40Gy1h5JnWf_Op5t.jpg)

> [critical regioin](https://dev.to/rinsama77/process-synchronization-with-busy-waiting-4gho)

여기서 **임계 구역(critical region)**은 공유 데이터에 접근하는 코드로, 하나의 스레드의 배타적인 사용이 보장되어야 한다. **진입 코드(entry code)**와 **출구 코드(exit code)**를 두어 임계 구역에 대한 상호배제를 만든다.

- 진입 코드 : 다른 스레드가 임계 구역에 있는지 체크하여 없으면 다른 스레드가 들어오지 못하도록 하고, 있으면 안에 있는 스레드가 임계 구역을 벗어나기를 기다림
- 출구 코드 : 임계 구역의 실행을 마치면 대기 중인 스레드나 다른 스레드가 임계 구역에 들어올 수 있도록 들어오지 못하게 조치를 취한 것을 해제함

상호배제는 Peterson의 알고리즘 등과 같은 소프트웨어적인 방법과 인터럽트 서비스 금지, 원자 명령 사용과 같은 하드웨어적인 방법으로 구현할 수 있다. 다만 소프트웨어적 방법은 실제 구현 시에 여러 문제가 있어 오늘날 하드웨어적 방법을 주로 사용하므로, 하드웨어적으로 상호배제를 구현하는 방법에 대해서 자세히 살펴보도록 한다.👀

#### 1. 인터럽트 서비스 금지

임계 구역으로 진입할 때 진입 코드에서 인터럽트 서비스를 금지하는 명령어를 실행함으로써 **스레드가 임계 구역을 실행하는 중에 선점되지 않도록 하는 방법**이다.

![img](https://cdn-images-1.medium.com/max/1000/0*QdUKpfKzKjSpck1_.jpg)

> [disabling interrupt](https://dev.to/rinsama77/process-synchronization-with-busy-waiting-4gho)

그럴싸해 보이지만 CPU가 모든 인터럽트를 무시함으로써 언제 끝날지도 모르는 스레드가 완료될 때까지 무한정 기다려야 하므로 동기화의 목적에는 부합하지 않으며, 다중 CPU 시스템에서는 다른 코어에서 실행되는 스레드가 임계 구역 코드를 실행하는 것을 막지 못하므로 완벽한 해결책이라고 볼 수 없다.😕

#### 2. lock 변수 사용

`lock`이라는 변수를 두어 임계 구역에 진입할 때는 값을 1로, 빠져나올 때는 0으로 설정하여 임계 구역을 실행하고 있는 스레드가 있는지 확인하는 방법이다. 인터럽트 서비스 금지와 달리 문도 있고 동시에 임계 구역에 진입하는 것을 막는 괜찮은 방법 같아 보이지만 `lock`이 생김으로 인해 임계 구역에 진입하기 위한 경쟁뿐만 아니라 `lock`을 위한 경쟁까지 하게 되었다.😞

![img](https://cdn-images-1.medium.com/max/1000/0*homjx_nQ5iXj8fQ2.jpg)

> [lock variable](https://dev.to/rinsama77/process-synchronization-with-busy-waiting-4gho)

#### 3. 원자 명령 사용

아래 그림은 좌측 소스 코드를 실행하는 두 가지 시나리오를 나타낸 것이다. 한 번 살펴보도록 하자.

*Scenario 1*에서는 한 스레드의 명령이 모두 수행된 후에 다른 스레드가 명령을 수행하기 때문에 공유 변수 `val`에 올바른 값이 저장되었음을 확인할 수 있다.

![img](https://cdn-images-1.medium.com/max/1000/0*s6FkJ1PtLziHiKU9)

> [atomic vs non-atomic operation](https://preshing.com/20130618/atomic-vs-non-atomic-operations/)

그러나 *Scenario 2*에서는 *Thread 0*에서 `val`을 load 하고 1을 더한 다음 미처 결괏값을 `val`에 담기 전에 컨텍스트 스위칭이 발생하여 *Thread 0*의 TCB(Thread Control Block)에 CPU 레지스터 값들을 저장한다. 이제 *Thread 1*이 스케줄 되어 `val`을 load 하면 이전 스레드에서 아직 값을 담지 못했기 때문에 0인 상태로, 또다시 컨텍스트 스위칭이 발생해서 *Thread 1*의 TCB에 값을 저장한다. 그리고 *Thread 0*이 스케줄 되면 *Thread 0*의 TCB에 기록해 둔 레지스터 값들을 CPU에 복귀시켜 명령을 실행함으로써 비로소 `val`의 값은 1이 된다. 다시 컨텍스트 스위칭이 발생하여 *Thread 1*이 스케줄 되면 마찬가지로 TCB에 저장된 레지스터 값들을 복귀시킨다. 당시 `val`은 0인 상태였고 이 값에 1을 더하고 값을 변수에 담으면 다시 1이 된다. 이는 기대한 값 2가 아니다.

이러한 문제가 발생한 원인은 이미 위의 그림에서 확인했듯이, 우리가 작성하는 **한 줄의 코드는 사실 여러 줄의 기계어 명령으로 이루어져 있기 때문**이다. 코드에 해당하는 모든 기계어 명령이 수행되고 나서 다른 코드의 명령을 수행할 경우에는 별로 문제가 되지 않겠지만, CPU가 기계어 명령을 순차적으로 실행하는 도중에 컨텍스트 스위칭이 발생하게 될 경우 문제가 발생할 수 있다.

그래서 상호배제를 위해 특별히 설계된 CPU 명령인 **원자 명령**으로 여러 줄의 명령을 실행하는 도중에 컨텍스트 스위칭이 일어나지 않도록 명령들을 하나의 명령으로 만들어 위와 같은 문제가 발생하지 않도록 한다.

### 멀티 스레드 동기화 기법

뮤텍스(Mutex), 스핀락(Spinlock), 세마포어(Semaphore) 등 다양한 방법으로 멀티 스레드를 동기화 할 수 있다. 과제와 크게 관련성은 없지만 세마포어가 언급되므로 어떤 기법들인지만 살펴보자.

#### 1. 뮤텍스(Mutex)

`lock`을 이용하여 오직 한 스레드만이 자원을 독점적으로 사용하도록 하는 동기화 기법으로, 대기 큐가 존재하며 임계 구역의 실행 시간이 짧은 경우에는 `lock`이 잠겨있는 시간보다 스레드가 sleep 상태에서 깨어나는데 더 긴 시간이 낭비되어 비효율적이다. 따라서 임계 구역의 실행 시간이 긴 경우와 단일 CPU 시스템, 사용자 프로그램에 적합하다.

#### 2. 스핀락(Spinlock)

뮤텍스와 마찬가지로 `lock`을 기반으로 하는 동기화 기법이지만 대기 큐가 없고 `lock`이 풀릴 때까지 무한 루프를 돌면서 `lock`을 검사하는 코드를 실행(busy-waiting) 하기 때문에 단일 CPU를 가진 운영체제에서는 의미 없이 기다리며 CPU를 낭비하면서도 다른 스레드의 실행 기회도 빼앗아 비효율적이다. 따라서 임계 구역의 코드가 짧은 경우와 멀티 코어를 가진 시스템, 커널 코드나 인터럽트 서비스 루틴에 효과적이다.

#### 3. 세마포어(Semaphore)

동시에 사용할 수 있는 하나의 자원에 대해 스레드들이 공유하도록 관리하는 동기화 프로그래밍 기법이자 공유 자원의 개수를 나타내는 변수로, 하나의 자원은 여러 인스턴스를 포함한다. 자원에 대한 다중 스레드의 원활한 공유를 목적으로 하며, P(Proberen: try in Dutch)/V(Verhogen: increment in Dutch) 연산을 통해 대기 큐나 무한 루프 방식으로 자원을 얻을 때까지 대기(busy-waiting) 하다가 자원 사용을 마치면 대기 스레드에 알려 스레드 동기화를 이룬다.

<hr/>

다음 포스팅에서는 Priority Scheduling and Synchronization을 해결해보도록 할 예정이다.