## 1–3. CPU Scheduling🙋

이번 과제를 수행하기 위해서 **CPU 스케줄링(CPU Scheduling)**에 대해 알아보자.

### CPU 스케줄링(CPU Scheduling)

**CPU 스케줄링**은 메모리에서 실행을 기다리는 준비 상태의 스레드 중 하나를 선택하여 CPU를 할당하는 과정을 말한다. 이를 통해서 **CPU가 가능한 쉬지 않도록 만들어 활용률을 높임**에 따라 컴퓨터 시스템이 시간당 더 많은 프로세스를 처리하도록 한다.

CPU 스케줄링을 담당하는 별도의 커널 스레드나 프로세스가 있는 것은 아니고, 스케줄링이 필요할 때 시스템 호출이나 인터럽트 서비스 루틴이 서비스를 마치는 마지막 단계에서 다른 커널에 의해 호출되는 함수로 작성된 커널 코드의 일부인 스케줄링 코드가 디스패처(dispatcher)를 호출하여 스케줄링으로 선택된 스레드가 CPU에 의해 실행되도록 한다.

> **디스패치(dispatch)**는 스케줄링된 프로세스나 스레드를 CPU에 보내 실행시킨다는 것을 의미한다. 실제로 프로세스나 스레드를 CPU에 보낼 수는 없고, CPU 레지스터에 스케줄링된 스레드의 **컨텍스트를 복귀**시켜 CPU가 스레드를 실행하도록 한다.

#### 선점 스케줄링과 비선점 스케줄링

선점 스케줄링과 비선점 스케줄링은 실행 중인 프로세스나 스레드를 강제로 중단시키고 다른 프로세스나 스레드를 실행시키는지 여부에 따라 분류한다.

**선점 스케줄링**은 아래와 같은 상황에서 커널이 현재 실행 중인 스레드를 강제로 중단시켜 준비 리스트로 이동시키고 CPU를 스케줄링을 통해 선택된 스레드에게 넘겨주는 방식이다. 대부분의 운영체제는 선점 스케줄링을 사용한다.

- 타임 슬라이스가 소진되어 타이머 인터럽트가 발생할 때
- 타임 슬라이스 전이라도 프로세스가 종료되었을 때
- 인터럽트나 시스템 호출이 종료된 상황에서 현재 스레드보다 상위 우선순위 스레드가 준비 상태에 있을 때

**비선점 스케줄링**은 먼저 실행을 시작한 프로세스가 종료되거나 자발적으로 CPU를 양보하거나(ex. `yield()` 시스템 콜) CPU를 더 이상 사용할 수 없는 상황(ex. I/O block, sleep 등)이 될 때까지는 강제로 중단시키지 않는 방식이다.

#### CPU 스케줄링 알고리즘

*FCFS(First Come First Served), SJF(Shortest Job First), SRTF(Shortest Remaining Time First), RR(Round-Robin), Priority Scheduling(Fixed Priority Preemptive Scheduling), MLQ(Multi-level Queue), MLFQ(Multi-level Feedback Queue)* 등 다양한 CPU 스케줄링 알고리즘이 있지만 이번 과제와 관련된 **RR**과 **Priority Scheduling**에 대해서 중점적으로 살펴보자.

> 📕 **용어 정리**
>
> - 타임 슬라이스 : 커널이 타이머의 도움을 받아 주기적으로 CPU 스케줄링을 실행하는 시간 간격
> - 기아(starvation) : 스레드가 스케줄링 시 선택되지 못한 상태로 오랫동안 준비 리스트에 존재하는 상황
> - 에이징(aging) : 프로세스가 준비 리스트에 머무르는 시간에 비례하게 프로세스의 우선순위를 높이는 기법이자 기아의 해결책

##### ✏️ **RR(Round-Robin)**

*Round Robin*은 프로세스들이 대기하는 준비 리스트를 원형 큐로 구축하여 모든 프로세스들에게 공평한 실행 기회를 주기 위해 **타임 슬라이스** 간격으로 돌아가며 선택하는 선점 스케줄링 알고리즘이다.

타임 슬라이스마다 돌아가며 실행되기 때문에 **공정하고 기아현상이 발생하지 않으며** 구현이 쉽다는 장점이 있지만 잦은 스케줄링 때마다 발생하는 **컨텍스트 스위칭 오버헤드가 크며**, 특히 타임 슬라이스가 작을 경우 스케줄링이 더 빈번하게 이루어져 성능 저하도 심해진다.

타임 슬라이스의 크기에 따라 FCFS 또는 SJF와 유사한 결과를 보인다.

- 타임 슬라이스가 클수록 단번에 완료되는 프로세스의 비율이 높아지면 FCFS와 유사
- 타임 슬라이스가 작을수록 여러 번에 걸쳐 실행되므로 처리 시간이 짧은 프로세스가 먼저 종료되어 SJF나 SRTF와 유사

![img](https://cdn-images-1.medium.com/max/800/1*wYlmZeE8kE5FQSSpSPGYFA.png)

> *Round Robin Scheduling*

##### ✏️ **Priority Scheduling**

*Priority Scheduling*은 우선순위로 프로세스들이 정렬된 준비 리스트 큐가 있어 **철저히 우선순위에 따라** 프로세스를 실행시키는 알고리즘이다. 선점 스케줄링 방식과 비선점 스케줄링 방식 둘 다 가능하지만 프로젝트와 관련성이 있는 선점 알고리즘은 실행 중인 프로세스가 종료되거나 더 높은 우선순위를 가진 프로세스가 오면 스케줄링을 다시 시행한다.

순위가 높은 프로세스일수록 대기 시간과 응답시간이 짧으며 프로세스마다 고정된 우선순위를 가지는 실시간 시스템에서 주로 사용된다. 지속적으로 높은 순위의 프로세스가 큐에 진입하게 될 경우 기아 발생 가능성이 있지만 aging으로 해결할 수 있다.

![img](https://cdn-images-1.medium.com/max/800/1*DpCqtuiNuJSUqHtPThj9hg.png)

> *Preemptive Priority Scheduling*

<hr />

지금까지 CPU 스케줄링에 대해서 정리해보았다. 개념을 이해하는 것과 과제 수행은 또 다른 문제이긴 하지만 조금이나마 도움이 되었기를 바란다. 다음 포스팅에서는 Priority Scheduling 과제를 해결해 볼 것이다.🐱‍💻
